<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Добавление нового торрента</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 13px;
      background: #f0f0f0;
      color: #333;
      padding: 12px;
      display: flex;
      flex-direction: column;
      height: 100vh;
      min-height: 420px;
    }
    body.dark {
      background: #2d2d2d;
      color: #e0e0e0;
    }
    .row { margin-bottom: 10px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .row label { min-width: 130px; }
    .row input[type="text"], .row input[type="number"] { flex: 1; min-width: 180px; padding: 6px 8px; height: 32px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
    .row input[type="text"]:focus, .row input[type="number"]:focus { outline: none; border-color: #2171bd; box-shadow: 0 0 0 1px #2171bd; }
    .row input[type="number"] { width: 70px; flex: none; }
    .row select { flex: 1; min-width: 180px; padding: 6px 8px; height: 32px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; background: #fff; font-size: 13px; font-family: inherit; }
    .row select:focus { outline: none; border-color: #2171bd; }
    body.dark .row input { background: #3d3d3d; color: #e0e0e0; border: 1px solid #555; }
    body.dark .row select { background: #3d3d3d; color: #e0e0e0; border: 1px solid #555; }
    body.dark .row select:focus { border-color: #5da5e8; }
    body.dark .row input:focus { border-color: #5da5e8; box-shadow: 0 0 0 1px #5da5e8; }
    body.dark .row input:-webkit-autofill,
    body.dark .row input:-webkit-autofill:hover,
    body.dark .row input:-webkit-autofill:focus,
    body.dark .row input:-webkit-autofill:active { -webkit-text-fill-color: #e0e0e0; -webkit-box-shadow: 0 0 0 30px #3d3d3d inset; caret-color: #e0e0e0; }
    .section {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .section.content-section {
      flex: 1 1 0;
      min-height: 120px;
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;
    }
    body.dark .section { background: #3d3d3d; border-color: #555; }
    .section-title { font-weight: 600; margin-bottom: 8px; }
    .file-list {
      border: 1px solid #ccc;
      background: #fff;
      flex: 1 1 0;
      min-height: 60px;
      overflow: auto;
      border-radius: 4px;
      padding: 4px 0;
    }
    body.dark .file-list { background: #3d3d3d; border-color: #555; }
    .tree-node { padding: 2px 8px; display: flex; align-items: center; gap: 6px; min-height: 24px; }
    .tree-node:hover { background: rgba(0,0,0,0.04); }
    body.dark .tree-node:hover { background: rgba(255,255,255,0.06); }
    .tree-node .tree-toggle {
      width: 16px; flex-shrink: 0; cursor: pointer; user-select: none; color: #666;
      font-size: 10px; line-height: 1; padding: 0 2px;
    }
    body.dark .tree-node .tree-toggle { color: #999; }
    .tree-node .tree-toggle::before { content: '▶'; }
    .tree-node.expanded .tree-toggle::before { content: '▼'; }
    .tree-node.leaf .tree-toggle { visibility: hidden; width: 16px; }
    .tree-node input[type="checkbox"] { flex-shrink: 0; margin: 0; }
    .tree-node .name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 13px; }
    .tree-node .size { flex-shrink: 0; color: #666; font-size: 12px; }
    body.dark .tree-node .size { color: #999; }
    .tree-children { margin-left: 16px; border-left: 1px solid #ddd; padding-left: 4px; }
    body.dark .tree-children { border-left-color: #555; }
    .tree-children.collapsed { display: none; }
    .buttons { flex-shrink: 0; padding: 12px 0; display: flex; justify-content: flex-end; gap: 8px; }
    .buttons button { padding: 8px 20px; cursor: pointer; border-radius: 4px; border: 1px solid #999; background: #f5f5f5; font-size: 13px; color: #333; }
    body.dark .buttons button { background: #555; border-color: #666; color: #e0e0e0; }
    .buttons button.primary { background: #2171bd; color: #fff; border-color: #2171bd; }
    .buttons button.primary:hover { background: #1a5a94; }
    body.dark .buttons button.primary { background: #2171bd; border-color: #2171bd; }
    .buttons button:disabled { opacity: 0.6; cursor: not-allowed; }
    .size-line { color: #666; margin-bottom: 6px; }
    body.dark .size-line { color: #999; }
    .select-buttons { flex-shrink: 0; margin-bottom: 6px; display: flex; gap: 8px; }
    .row .btn-primary { height: 32px; padding: 0 20px; cursor: pointer; border-radius: 4px; border: 1px solid #2171bd; background: #2171bd; color: #fff; font-size: 13px; font-family: inherit; box-sizing: border-box; }
    .row .btn-primary:hover { background: #1a5a94; }
    body.dark .row .btn-primary { background: #2171bd; border-color: #2171bd; }
    .btn-link { background: none; border: none; color: #2171bd; cursor: pointer; padding: 0 4px; font-size: 12px; font-family: inherit; }
    .btn-link:hover { text-decoration: underline; }
    body.dark .btn-link { color: #5da5e8; }
    .error { color: #c00; margin-top: 8px; }
    body.dark .error { color: #f66; }
    .loading { color: #666; }
    body.dark .loading { color: #999; }
  </style>
</head>
<body>
  <div class="section">
    <div class="row">
      <label for="savepath">Папка для загрузки:</label>
      <input type="text" id="savepath" placeholder="Путь для сохранения" list="savepath-list" />
      <datalist id="savepath-list"></datalist>
      <button type="button" class="btn-primary" id="browse">Обзор...</button>
    </div>
    <div class="row">
      <label for="rename">Сохранить как:</label>
      <input type="text" id="rename" placeholder="Имя папки/файла (необязательно)" />
    </div>
    <div class="row">
      <label for="category">Категория:</label>
      <select id="category"></select>
    </div>
    <div class="row">
      <label></label>
      <label style="min-width:auto;font-weight:normal;">
        <input type="checkbox" id="startTorrent" checked /> Запустить торрент
      </label>
    </div>
  </div>
  <div class="section content-section">
    <div class="section-title">Содержимое торрента</div>
    <div class="size-line">Размер: <span id="totalSize">—</span></div>
    <div class="size-line">Свободно на диске: <span id="freeSpace">—</span></div>
    <div class="select-buttons">
      <button type="button" class="btn-link" id="selectAll">Выбрать все</button>
      <button type="button" class="btn-link" id="deselectAll">Отменить выбор</button>
    </div>
    <div class="file-list" id="fileList"></div>
  </div>
  <div class="buttons">
    <button type="button" id="cancel">Отмена</button>
    <button type="button" id="ok" class="primary">OK</button>
  </div>
  <div id="error" class="error" style="display:none;"></div>
  <script>
    const params = new URLSearchParams(window.location.search);
    const torrentPath = params.get('path') ? decodeURIComponent(params.get('path')) : null;
    const theme = params.get('theme') || 'light';
    if (theme === 'dark') document.body.classList.add('dark');

    let torrentInfo = null;
    let filePriorities = [];

    function lastPathSegment(pathStr) {
      const p = (pathStr || '').trim().replace(/\\/g, '/');
      const parts = p.split('/').filter(Boolean);
      return parts.length ? parts[parts.length - 1] : '';
    }

    function formatSize(bytes) {
      if (bytes === 0) return '0 Б';
      const k = 1024;
      const sizes = ['Б', 'КБ', 'МБ', 'ГБ', 'ТБ'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
    }

    async function fillCategorySelect(selectDefaultCategory) {
      const sel = document.getElementById('category');
      const currentValue = sel.value;
      const catResult = await window.addTorrentAPI.getCategories();
      const serverCategories = (catResult && catResult.categories && Array.isArray(catResult.categories)) ? catResult.categories : [];
      sel.innerHTML = '';
      const optEmpty = document.createElement('option');
      optEmpty.value = '';
      optEmpty.textContent = '— Без категории —';
      sel.appendChild(optEmpty);
      const added = new Set(['']);
      serverCategories.forEach(name => {
        if (name && !added.has(name)) {
          added.add(name);
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          sel.appendChild(opt);
        }
      });
      if (selectDefaultCategory && !added.has(selectDefaultCategory)) {
        const opt = document.createElement('option');
        opt.value = selectDefaultCategory;
        opt.textContent = selectDefaultCategory;
        sel.appendChild(opt);
        added.add(selectDefaultCategory);
      }
      const toSelect = selectDefaultCategory != null ? selectDefaultCategory : currentValue;
      if (toSelect && !added.has(toSelect)) {
        const opt = document.createElement('option');
        opt.value = toSelect;
        opt.textContent = toSelect;
        sel.appendChild(opt);
      }
      if (toSelect && Array.from(sel.options).some(o => o.value === toSelect)) sel.value = toSelect;
      else if (!toSelect) sel.value = '';
    }

    function setCategoryFromPath(pathStr) {
      const name = lastPathSegment(pathStr);
      const sel = document.getElementById('category');
      const opts = Array.from(sel.options);
      const hasOpt = opts.some(o => o.value === name);
      if (!hasOpt && name) {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        sel.appendChild(opt);
      }
      sel.value = name || '';
    }

    async function init() {
      if (!torrentPath) {
        document.getElementById('error').textContent = 'Не указан файл торрента.';
        document.getElementById('error').style.display = 'block';
        return;
      }
      const savePathsData = await window.addTorrentAPI.getStoredSavePath();
      const defaultPath = (savePathsData && savePathsData.default) || '';
      const recentPaths = (savePathsData && savePathsData.recent) || [];
      document.getElementById('savepath').value = defaultPath;
      const datalist = document.getElementById('savepath-list');
      datalist.innerHTML = '';
      recentPaths.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p;
        datalist.appendChild(opt);
      });
      await fillCategorySelect(lastPathSegment(defaultPath));
      const info = await window.addTorrentAPI.getTorrentInfo(torrentPath);
      if (info.error) {
        document.getElementById('error').textContent = 'Ошибка чтения торрента: ' + info.error;
        document.getElementById('error').style.display = 'block';
        return;
      }
      torrentInfo = info;
      document.getElementById('totalSize').textContent = formatSize(info.totalSize);
      document.getElementById('rename').value = info.name || '';
      const listEl = document.getElementById('fileList');
      listEl.innerHTML = '';
      filePriorities = info.files.map(() => 1);
      const tree = buildFileTree(info.files);
      listEl.appendChild(renderTree(tree));
    }

    function buildFileTree(files) {
      const root = { name: '', children: {}, files: [] };
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        const parts = (f.path || '').replace(/\\/g, '/').split('/').filter(Boolean);
        let node = root;
        for (let j = 0; j < parts.length; j++) {
          const part = parts[j];
          const isFile = j === parts.length - 1;
          if (isFile) {
            node.files.push({ index: i, length: f.length, path: f.path });
          } else {
            if (!node.children[part]) node.children[part] = { name: part, children: {}, files: [] };
            node = node.children[part];
          }
        }
      }
      return root;
    }

    function collectIndices(node) {
      const idx = [];
      (node.files || []).forEach(f => idx.push(f.index));
      Object.values(node.children || {}).forEach(c => idx.push(...collectIndices(c)));
      return idx;
    }

    function nodeSize(node) {
      let s = (node.files || []).reduce((a, f) => a + f.length, 0);
      Object.values(node.children || {}).forEach(c => s += nodeSize(c));
      return s;
    }

    function renderTree(node) {
      const wrap = document.createElement('div');
      const childEntries = Object.entries(node.children || {}).sort((a, b) => a[0].localeCompare(b[0]));
      (node.files || []).forEach(f => {
        const row = document.createElement('div');
        row.className = 'tree-node leaf';
        const empty = document.createElement('span');
        empty.className = 'tree-toggle';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = true;
        cb.dataset.index = String(f.index);
        cb.addEventListener('change', (e) => { filePriorities[f.index] = e.target.checked ? 1 : 0; });
        const label = document.createElement('span');
        label.className = 'name';
        label.textContent = (f.path || '').split(/[/\\]/).pop() || 'file';
        label.title = f.path;
        const sizeSpan = document.createElement('span');
        sizeSpan.className = 'size';
        sizeSpan.textContent = formatSize(f.length);
        row.append(empty, cb, label, sizeSpan);
        wrap.appendChild(row);
      });
      childEntries.forEach(([_, child]) => {
        const hasKids = Object.keys(child.children).length > 0 || (child.files || []).length > 0;
        const row = document.createElement('div');
        row.className = 'tree-node' + (hasKids ? '' : ' leaf');
        const toggle = document.createElement('span');
        toggle.className = 'tree-toggle';
        if (hasKids) {
          toggle.addEventListener('click', () => {
            const kids = row.nextElementSibling;
            if (kids) {
              kids.classList.toggle('collapsed');
              row.classList.toggle('expanded');
            }
          });
        }
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = true;
        const indices = collectIndices(child);
        if (indices.length) {
          cb.dataset.indices = JSON.stringify(indices);
          cb.addEventListener('change', (e) => {
            const val = e.target.checked ? 1 : 0;
            JSON.parse(cb.dataset.indices).forEach(idx => filePriorities[idx] = val);
            const kids = row.nextElementSibling;
            if (kids) kids.querySelectorAll('input[type="checkbox"]').forEach(c => c.checked = e.target.checked);
          });
        }
        const label = document.createElement('span');
        label.className = 'name';
        label.textContent = child.name;
        const sizeSpan = document.createElement('span');
        sizeSpan.className = 'size';
        sizeSpan.textContent = formatSize(nodeSize(child));
        row.append(toggle, cb, label, sizeSpan);
        wrap.appendChild(row);
        const childrenWrap = document.createElement('div');
        childrenWrap.className = 'tree-children collapsed';
        childrenWrap.appendChild(renderTree(child));
        wrap.appendChild(childrenWrap);
      });
      return wrap;
    }

    document.getElementById('browse').addEventListener('click', async () => {
      const current = document.getElementById('savepath').value;
      const chosen = await window.addTorrentAPI.openFolderDialog(current);
      if (chosen) {
        document.getElementById('savepath').value = chosen;
        setCategoryFromPath(chosen);
      }
    });

    document.getElementById('savepath').addEventListener('input', () => {
      setCategoryFromPath(document.getElementById('savepath').value);
    });

    document.getElementById('selectAll').addEventListener('click', () => {
      filePriorities.fill(1);
      document.querySelectorAll('#fileList input[type="checkbox"]').forEach(cb => { cb.checked = true; });
    });
    document.getElementById('deselectAll').addEventListener('click', () => {
      filePriorities.fill(0);
      document.querySelectorAll('#fileList input[type="checkbox"]').forEach(cb => { cb.checked = false; });
    });

    document.getElementById('ok').addEventListener('click', async () => {
      const savepath = document.getElementById('savepath').value.trim();
      const url = await window.addTorrentAPI.getWebUiUrl();
      if (!url) {
        document.getElementById('error').textContent = 'Сначала подключитесь к qBittorrent (Файл → Подключение...).';
        document.getElementById('error').style.display = 'block';
        return;
      }
      document.getElementById('ok').disabled = true;
      document.getElementById('error').style.display = 'none';
      const result = await window.addTorrentAPI.addTorrent({
        torrentPath,
        savepath: savepath || undefined,
        rename: document.getElementById('rename').value.trim() || undefined,
        category: document.getElementById('category').value.trim() || undefined,
        startPaused: !document.getElementById('startTorrent').checked,
        filePriorities: filePriorities,
      });
      document.getElementById('ok').disabled = false;
      if (result.ok) {
        window.close();
      } else {
        document.getElementById('error').textContent = result.error || 'Ошибка добавления торрента.';
        document.getElementById('error').style.display = 'block';
      }
    });

    document.getElementById('cancel').addEventListener('click', () => window.close());

    init();
  </script>
</body>
</html>
